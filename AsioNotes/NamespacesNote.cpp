Пространства имен Boost.Asio

Все в Boost.Asio находится в пространстве имен boost::asio или его подпространстве, рассмотрим их:
boost::asio: Это где находятся все основные классы и функции. Главные классы это io_service и streambuf. Здесь находятся такие функции как read, read_at, read_until, их асинхронные копии, а так же функции записи и их асинхронные копии.
boost::asio::ip: Это место, где находится сетевая часть библиотеки. Основные классы это address, endpoint, tcp, udp, icmp, а основные функции это connect и async_connect. Обратите внимание, что socket в boost::asio::ip::tcp::socket это просто typedef внутри класса boost::asio::ip::tcp.
boost::asio::error: Это пространство имен содержит коды ошибок, которые вы можете получить при вызове подпрограммы ввода/вывода
boost::asio::ssl: Это пространство имен содержит классы, имеющие дело с SSL.
boost::asio::local: Это пространство имен содержит POSIX-специфичные классы
boost::asio::windows: Это пространство имен содержит Windows-специфичные классы


_____________________________
IP адреса:

Для работы с IP адресами Boost.Asio предоставляет классы ip::address, ip::address_v4 и ip::address_v6.
Они предоставляют множество функций. Вот наиболее важные из них:
ip::address(v4_or_v6_address): Эта функция конвертирует v4 или v6 адрес в ip::address
ip::address:from_string(str): Эта функция создает адрес из IPv4 адреса (разделенных точками) или из IPv6 (шестнадцатиричный формат)
ip::address::to_string(): Эта функция возвращает представление адреса в благоприятном строчном виде
ip::address_v4::broadcast([addr, mask]): Эта функция создает broadcast адрес
ip::address_v4::any(): Эта функция возвращает адрес, который олицетворяет любой адрес
ip::address_v4::loopback(), ip_address_v6::loopback(): Эта функция возвращает шлейф адресов (из v4/v6 протокола)
ip::host_name(): Эта функция возвращает имя текущего хоста в виде строчки

Скорее всего чаще всего вы будете использовать функцию ip::address::from_string:

ip::address addr = ip::address::from_string("127.0.0.1");

__________________________________
Конечные точки (Endpoints):

Конечная точка это адрес подключения вместе с портом. Каждый тип сокетов имеет свой endpoint класс, например, ip::tcp::endpoint, ip::udp::endpoint, и ip::icmp::endpoint.
Если вы хотите подключиться к localhost по 80 порту, то вам нужно написать следующее:

ip::tcp::endpoint ep( ip::address::from_string("127.0.0.1"), 80);

Вы можете создать конечную точку тремя способами:
endpoint(): конструктор по умолчанию и он может быть иногда использован для UDP/ICMP сокетов
endpoint(protocol, port): обычно используется на серверных сокетах для приема новых подключений
endpoint(addr, port): создание конечной точки по адресу и порту

Вот несколько примеров:

    ip::tcp::endpoint ep1;
    ip::tcp::endpoint ep2(ip::tcp::v4(), 80);
    ip::tcp::endpoint ep3( ip::address::from_string("127.0.0.1), 80);
______________________________________________
Сокеты:

Boost.Asio включает в себя три типа классов сокетов: ip::tcp, ip::udp, и ip::icmp, ну и, конечно же, расширяется. Вы можете создать свой собственный класс сокета, хотя это довольно сложно. В случае если вы все же решите сделать это посмотрите boost/ asio/ip/tcp.hpp, boost/asio/ip/udp.hpp, и boost/asio/ip/icmp.hpp. Все они это довольно маленькие классы с внутренними typedef ключевыми словами.
Вы можете думать о классах ip::tcp, ip::udp, ip::icmp как о заполнителях; они дают возможность легко добраться до других классов/функций, которые определяются следующим образом:
ip::tcp::socket, ip::tcp::acceptor, ip::tcp::endpoint, ip::tcp::resolver, ip::tcp::iostream
        ip::udp::socket, ip::udp::endpoint, ip::udp::resolver
ip::icmp::socket, ip::icmp::endpoint, ip::icmp::resolver

Класс socket создает соответствующий сокет. Вы всегда передаете экземпляр io_service в конструктор:

io_service service;
ip::udp::socket sock(service)
sock.set_option(ip::udp::socket::reuse_address(true));

Каждое имя сокета имеет typedef:
ip::tcp::socket= basic_stream_socket
ip::udp::socket= basic_datagram_socket<udp>
ip::icmp::socket= basic_raw_socket


Коды ошибок синхронных функций

Все синхронные функции имеют перегрузки, которые выбрасывают исключения или возвращают код ошибки, как показано ниже:

sync_func( arg1, arg2 ... argN); // throws
boost::system::error_code ec;
sync_func( arg1 arg2, ..., argN, ec); // returns error code

_______________________________________________
Функции сокетов:

        Все функции разделены на несколько групп. Не все функции доступны для каждого типа сокета. Список в конце этого раздела покажет вам, какие функции к какому классу сокетов относятся.
Отметим, что все асинхронные функции отвечают мгновенно, в то время как их коллеги синхронные отвечают только после того, как операция была завершена.

Соединительно-связывающие функции

Это функции, которые подключаются или соединяются с сокетом, отключают его и делают запрос о подключении, активно оно или нет:
assign(protocol,socket): эта функция присваивает сырой(естественный) сокет к экземпляру сокета. Используйте ее при работе с наследуемым кодом (то есть когда сырые сокеты уже созданы).
open(protocol): эта функция открывает сокет с заданным IP-протоколом (v4 или v6). Вы будете использовать ее в основном для UDP/ICMP сокетов или серверных сокетов
        bind(endpoint): эта функция связывается с данным адресом.
connect(endpoint): эта функция синхронно подключается по данному адресу.
async_connect(endpoint): эта функция асинхронно подключается по данному адресу.
is_open(): эта функция возвращает true если сокет открыт.
close(): эта функция закрывает сокет. Любые асинхронные операции на этом сокете немедленно прекращаются и возвращают error::operation_aborted код ошибки.
shutdown(type_of_shutdown): эта функция отключает операцию send , receive или обе сразу же после вызова.
cancel(): эта функция отменяет все асинхронные операции на этом сокете. Все асинхронные операции на этом сокете будут немедленно завершены и вернут error::operation_aborted код ошибки.

Приведем небольшой пример:

ip::tcp::endpoint ep( ip::address::from_string("127.0.0.1"), 80);
ip::tcp::socket sock(service);
sock.open(ip::tcp::v4());
sock.connect(ep);
sock.write_some(buffer("GET /index.html\r\n"));
char buff[1024]; sock.read_some(buffer(buff,1024));
sock.shutdown(ip::tcp::socket::shutdown_receive);
sock.close();